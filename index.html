<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Rhino Mesh Viewer â€” Metadata</title>
  <style>
    body { margin: 0; overflow: hidden; background: #f5f5f5; }
    canvas { display: block; }
    #infoBox {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: rgba(255,255,255,0.95);
      color: black;
      padding: 10px;
      border-radius: 6px;
      max-width: 350px;
      font-family: monospace;
      font-size: 12px;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
<div id="infoBox">Click on a mesh to see metadata...</div>

<!-- Three.js r146 + non-module OrbitControls -->
<script src="https://unpkg.com/three@0.146.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://unpkg.com/rhino3dm/rhino3dm.js"></script>

<script>
let scene, camera, renderer, controls, raycaster, mouse, rhino;

async function init() {
  rhino = await rhino3dm();

  scene = new THREE.Scene();

  // Camera
  camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(20,20,20);

  // Renderer
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0xf5f5f5, 1);
  document.body.appendChild(renderer.domElement);

  // OrbitControls (non-module)
  controls = new THREE.OrbitControls(camera, renderer.domElement);

  // Lights
  scene.add(new THREE.AmbientLight(0xffffff, 1.2));
  const hemi = new THREE.HemisphereLight(0xffffff,0x444444,0.6);
  hemi.position.set(0,200,0);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff,0.8);
  dir.position.set(50,50,50);
  scene.add(dir);

  // Raycaster & mouse
  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();
  window.addEventListener('click', onClick, false);
  window.addEventListener('resize', onWindowResize, false);

  // Load mesh .3dm
  const url = 'model.3dm'; // replace with your mesh .3dm
  const request = await fetch(url);
  const buffer = await request.arrayBuffer();
  const doc = rhino.File3dm.fromByteArray(new Uint8Array(buffer));

  for (let i=0; i<doc.objects().count; i++){
    const obj = doc.objects().get(i);
    const geom = obj.geometry();
    const attrs = obj.attributes();

    if (geom instanceof rhino.Mesh) {
      const threeMesh = meshToThree(geom);
      threeMesh.userData = extractMetadata(attrs, doc);
      scene.add(threeMesh);
    }
  }

  // Center camera
  const box = new THREE.Box3().setFromObject(scene);
  const center = box.getCenter(new THREE.Vector3());
  const size = box.getSize(new THREE.Vector3()).length();
  camera.position.set(center.x+size, center.y+size, center.z+size);
  camera.lookAt(center);
  controls.target.copy(center);
  controls.update();

  animate(); // start rendering
}

function meshToThree(rhinoMesh){
  const geometry = new THREE.BufferGeometry();
  const verts = [];
  const vertices = rhinoMesh.vertices();
  for(let i=0; i<vertices.count; i++){
    const pt = vertices.get(i);
    verts.push(pt[0], pt[1], pt[2]);
  }
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(verts,3));

  const indices = [];
  const faces = rhinoMesh.faces();
  for(let i=0; i<faces.count; i++){
    const f = faces.get(i);
    if(f.length===4){ indices.push(f[0],f[1],f[2]); indices.push(f[0],f[2],f[3]); }
    else if(f.length===3){ indices.push(f[0],f[1],f[2]); }
  }
  geometry.setIndex(indices);
  geometry.computeVertexNormals();

  return new THREE.Mesh(
    geometry,
    new THREE.MeshStandardMaterial({color:0xcccccc, metalness:0, roughness:1})
  );
}

function extractMetadata(attrs, doc){
  let meta = {
    name: attrs.name(),
    layer: doc.layers().get(attrs.layerIndex()).name,
    userStrings: {}
  };
  const us = attrs.userStrings();
  if(us) for(const [k,v] of us) meta.userStrings[k] = v;
  return meta;
}

function onClick(event){
  mouse.x = (event.clientX/window.innerWidth)*2-1;
  mouse.y = -(event.clientY/window.innerHeight)*2+1;
  raycaster.setFromCamera(mouse,camera);
  const intersects = raycaster.intersectObjects(scene.children,true);
  if(intersects.length>0) showMetadata(intersects[0].object.userData);
}

function showMetadata(data){
  const box = document.getElementById('infoBox');
  box.textContent = JSON.stringify(data,null,2);
}

function onWindowResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate(){
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}

// Initialize
init();
</script>
</body>
</html>
