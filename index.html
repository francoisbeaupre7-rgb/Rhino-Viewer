<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rhino Mesh Viewer — Metadata + Filters + Clear</title>
  <style>
    body { margin: 0; overflow: hidden; background: #f5f5f5; }
    canvas { display: block; }

    #filterBox {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.95);
      padding: 8px;
      border-radius: 6px;
      font-family: sans-serif;
      font-size: 13px;
      z-index: 5;
    }
    #filterBox select { margin: 3px 0; width: 200px; }

    #infoBox {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: rgba(255,255,255,0.95);
      color: black;
      padding: 10px;
      border-radius: 6px;
      max-width: 420px;
      font-family: monospace;
      font-size: 12px;
      white-space: pre-wrap;
      z-index: 5;
    }

    #clearBtn {
      display: none;
      margin-top: 8px;
      padding: 4px 8px;
      font-size: 12px;
      border: 1px solid #aaa;
      border-radius: 4px;
      background: #eee;
      cursor: pointer;
    }
    #clearBtn:hover { background: #ddd; }
    #qtyBox { margin-top: 6px; font-weight: bold; display: none; }
  </style>
</head>
<body>
  <div id="filterBox">
    <label>Key:</label><br>
    <select id="keySelect"></select><br>
    <label>Value:</label><br>
    <select id="valueSelect"></select><br>
    <div id="qtyBox">Qty: 0</div>
  </div>

  <div id="infoBox">
    Click on a mesh to see metadata...
    <br>
    <button id="clearBtn">Clear Selection</button>
  </div>

  <!-- Three.js r146 + non-module OrbitControls -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/rhino3dm/rhino3dm.js"></script>

  <script>
  // Colors
  const DEFAULT_COLOR = 0xcccccc;
  const FILTER_COLOR  = 0xffa500; // orange for filtered matches
  const SELECT_COLOR  = 0xff0000; // red for user selection

  let scene, camera, renderer, controls, raycaster, mouse, rhino;
  const meshes = [];           // all mesh THREE.Mesh objects
  const meshEdges = [];        // {mesh, line} pairs (edges)
  const allKeys = new Set();
  let selectedObjects = [];    // clicked/toggled selections
  let currentFilterKey = null;
  let currentFilterVal = null;

  async function init() {
    rhino = await rhino3dm();

    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(20,20,20);

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0xf5f5f5, 1);
    document.body.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 1.2));
    const hemi = new THREE.HemisphereLight(0xffffff,0x444444,0.6);
    hemi.position.set(0,200,0);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff,0.8);
    dir.position.set(50,50,50);
    scene.add(dir);

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();
    window.addEventListener('click', onClick, false);
    window.addEventListener('resize', onWindowResize, false);

    document.getElementById('clearBtn').addEventListener('click', clearSelection);

    // Load .3dm
    const url = 'model.3dm'; // <-- ensure model.3dm is next to this HTML
    const request = await fetch(url);
    const buffer = await request.arrayBuffer();
    const doc = rhino.File3dm.fromByteArray(new Uint8Array(buffer));

    for (let i=0; i<doc.objects().count; i++){
      const obj = doc.objects().get(i);
      const geom = obj.geometry();
      const attrs = obj.attributes();

      if (geom instanceof rhino.Mesh) {
        const mesh = meshToThree(geom);
        mesh.userData = extractMetadata(attrs, doc);
        meshes.push(mesh);

        // collect all user string keys if present
        const us = mesh.userData.userStrings || {};
        for (const k in us) allKeys.add(k);

        scene.add(mesh);
      }
    }

    // rotate scene to Z-up (same as your working code)
    scene.rotation.x = -Math.PI/2;

    // center camera
    const box = new THREE.Box3().setFromObject(scene);
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3()).length();
    camera.position.set(center.x+size, center.y+size, center.z+size);
    camera.lookAt(center);
    controls.target.copy(center);
    controls.update();

    setupUI();
    updateMeshColors();
    animate();
  }

  function meshToThree(rhinoMesh){
    const geometry = new THREE.BufferGeometry();
    const verts = [];
    const vertices = rhinoMesh.vertices();
    for(let i=0; i<vertices.count; i++){
      const pt = vertices.get(i);
      verts.push(pt[0], pt[1], pt[2]);
    }
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(verts,3));

    const indices = [];
    const faces = rhinoMesh.faces();
    for(let i=0; i<faces.count; i++){
      const f = faces.get(i);
      if(f.length===4){ indices.push(f[0],f[1],f[2]); indices.push(f[0],f[2],f[3]); }
      else if(f.length===3){ indices.push(f[0],f[1],f[2]); }
    }
    geometry.setIndex(indices);
    geometry.computeVertexNormals();

    const material = new THREE.MeshStandardMaterial({color: DEFAULT_COLOR, metalness:0, roughness:1});
    const mesh = new THREE.Mesh(geometry, material);

    // edges
    const edges = new THREE.EdgesGeometry(geometry);
    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color:0x000000}));
    line.position.copy(mesh.position);
    line.rotation.copy(mesh.rotation);
    scene.add(line);
    meshEdges.push({mesh, line});

    return mesh;
  }

  function extractMetadata(attrs, doc){
    let meta = {
      name: attrs.name || "",
      layer: doc.layers().get(attrs.layerIndex || 0).name,
      userStrings: {}
    };
    const us = attrs.getUserStrings ? attrs.getUserStrings() : null;
    if (us) {
      for (const [k,v] of us) meta.userStrings[k] = v;
    }
    return meta;
  }

  // central function to set mesh colors based on filter + selection
  function updateMeshColors(){
    meshes.forEach(m => {
      const isSelected = selectedObjects.indexOf(m) !== -1;
      const matchesFilter = currentFilterKey && currentFilterVal &&
        (m.userData.userStrings && m.userData.userStrings[currentFilterKey] === currentFilterVal);

      if (isSelected) {
        m.material.color.setHex(SELECT_COLOR);
      } else if (matchesFilter) {
        m.material.color.setHex(FILTER_COLOR);
      } else {
        m.material.color.setHex(DEFAULT_COLOR);
      }
    });
  }

  // Click: toggle selection of mesh. Selection overrides filter color.
  function onClick(event){
    mouse.x = (event.clientX/window.innerWidth)*2 - 1;
    mouse.y = - (event.clientY/window.innerHeight)*2 + 1;
    raycaster.setFromCamera(mouse, camera);

    // only test the meshes array (not edges)
    const intersects = raycaster.intersectObjects(meshes, true);
    if (intersects.length === 0) return;

    const obj = intersects[0].object;
    if (!obj.isMesh) return;

    const idx = selectedObjects.indexOf(obj);
    if (idx === -1) {
      // add selection
      selectedObjects.push(obj);
    } else {
      // toggle off
      selectedObjects.splice(idx, 1);
    }

    updateMeshColors();
    showMetadata();
  }

  // show metadata in infoBox (for clicked selections). If none selected show default message.
  function showMetadata(){
    const box = document.getElementById('infoBox');
    const btn = document.getElementById('clearBtn');

    if (selectedObjects.length === 0) {
      box.firstChild.nodeValue = "Click on a mesh to see metadata..."; // keep first text
      // but preserve the Clear button position — hide it
      btn.style.display = "none";
      // If you prefer to display filter status here, we could — currently filter qty is shown in qtyBox.
      return;
    }

    const info = { qty: selectedObjects.length, items: selectedObjects.map(o => o.userData) };
    // replace content but keep the Clear button element in DOM
    box.textContent = JSON.stringify(info, null, 2);
    // re-append clear button (so it's after the JSON)
    box.appendChild(document.getElementById('clearBtn'));
    btn.style.display = "inline-block";
  }

  function clearSelection(){
    selectedObjects.forEach(o => {
      // simply remove selection mark; updateMeshColors will restore proper color (filter/default)
    });
    selectedObjects = [];
    updateMeshColors();
    showMetadata();
  }

  function onWindowResize(){
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function animate(){
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }

  // ---------- UI ----------
  function setupUI(){
    const keySelect = document.getElementById('keySelect');
    const valueSelect = document.getElementById('valueSelect');
    const qtyBox = document.getElementById('qtyBox');

    // populate keys
    keySelect.innerHTML = "";
    if (allKeys.size === 0) {
      const opt = document.createElement('option');
      opt.value = ""; opt.textContent = "(no userStrings found)";
      keySelect.appendChild(opt);
      keySelect.disabled = true;
      valueSelect.disabled = true;
      return;
    }

    allKeys.forEach(k => {
      const opt = document.createElement('option');
      opt.value = k; opt.textContent = k;
      keySelect.appendChild(opt);
    });

    // when key changes: populate values (with placeholder)
    keySelect.addEventListener('change', () => {
      currentFilterKey = keySelect.value || null;
      currentFilterVal = null;

      // build list of distinct values for this key
      const values = new Set();
      meshes.forEach(m => {
        if (m.userData.userStrings && m.userData.userStrings[currentFilterKey]) {
          values.add(m.userData.userStrings[currentFilterKey]);
        }
      });

      valueSelect.innerHTML = "";
      // placeholder option
      const ph = document.createElement('option');
      ph.value = ""; ph.textContent = "-- select value --";
      valueSelect.appendChild(ph);

      values.forEach(v => {
        const opt = document.createElement('option');
        opt.value = v; opt.textContent = v;
        valueSelect.appendChild(opt);
      });

      qtyBox.style.display = "none";
      currentFilterVal = null;
      updateMeshColors();
    });

    // when a value is picked: highlight matches & show qty
    valueSelect.addEventListener('change', () => {
      const key = keySelect.value;
      const val = valueSelect.value;
      currentFilterKey = key || null;
      currentFilterVal = val || null;

      // count matches
      let count = 0;
      meshes.forEach(m => {
        if (currentFilterKey && currentFilterVal &&
            m.userData.userStrings && m.userData.userStrings[currentFilterKey] === currentFilterVal) {
          count++;
        }
      });

      if (currentFilterVal) {
        qtyBox.style.display = "block";
        qtyBox.textContent = "Qty: " + count;
      } else {
        qtyBox.style.display = "none";
      }

      updateMeshColors();
    });

    // initialize first key selected (but value remains unselected)
    keySelect.selectedIndex = 0;
    keySelect.dispatchEvent(new Event('change'));
  }

  // initialize viewer
  init().catch(e => {
    console.error(e);
    alert("Error initializing viewer. See console for details.");
  });

  </script>
</body>
</html>
