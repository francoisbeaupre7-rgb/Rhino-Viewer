<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Rhino Viewer â€” Metadata Click</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #f5f5f5;
    }
    canvas { display: block; }
    #infoBox {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.95);
      color: black;
      padding: 10px;
      border-radius: 6px;
      max-width: 350px;
      font-family: monospace;
      font-size: 12px;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <div id="infoBox">Click on a surface to see metadata...</div>

  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="https://unpkg.com/rhino3dm/rhino3dm.js"></script>

  <script>
    let scene, camera, renderer, raycaster, mouse, rhino;

    init();
    animate();

    async function init() {
      rhino = await rhino3dm();

      scene = new THREE.Scene();

      // Camera
      camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.set(30, 30, 30);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0xf5f5f5, 1);
      document.body.appendChild(renderer.domElement);

      // Lights
      scene.add(new THREE.AmbientLight(0xffffff, 1.2));
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
      hemiLight.position.set(0, 200, 0);
      scene.add(hemiLight);
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(50, 50, 50);
      scene.add(dirLight);

      // Raycaster
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
      window.addEventListener('click', onClick, false);

      // Load model
      const url = "model.3dm"; // put your 3dm file in the repo root
      const request = await fetch(url);
      const buffer = await request.arrayBuffer();
      const doc = rhino.File3dm.fromByteArray(new Uint8Array(buffer));

      console.log("Object count:", doc.objects().count);

      for (let i = 0; i < doc.objects().count; i++) {
        const obj = doc.objects().get(i);
        const geom = obj.geometry();
        const attrs = obj.attributes();

        let meshes = [];

        if (geom instanceof rhino.Mesh) {
          meshes.push(geom);
        } else if (geom instanceof rhino.Brep) {
          const brepMeshes = rhino.Mesh.createFromBrep(geom, null);
          if (brepMeshes) meshes.push(...brepMeshes);
        }

        meshes.forEach(m => {
          const threeMesh = meshToThree(m);

          // collect metadata
          let meta = {
            name: attrs.name(),
            layer: doc.layers().get(attrs.layerIndex()).name,
            userStrings: {}
          };
          const us = attrs.userStrings();
          if (us) {
            for (let [key, value] of us) {
              meta.userStrings[key] = value;
            }
          }
          threeMesh.userData = meta;

          scene.add(threeMesh);
        });
      }

      window.addEventListener('resize', onWindowResize, false);
    }

    function meshToThree(rhinoMesh) {
      const geometry = new THREE.BufferGeometry();

      const vertices = rhinoMesh.vertices();
      const verts = [];
      for (let i = 0; i < vertices.count; i++) {
        const pt = vertices.get(i);
        verts.push(pt[0], pt[1], pt[2]);
      }
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));

      const faces = rhinoMesh.faces();
      const indices = [];
      for (let i = 0; i < faces.count; i++) {
        const f = faces.get(i);
        if (f.length === 4) {
          indices.push(f[0], f[1], f[2]);
          indices.push(f[0], f[2], f[3]);
        } else if (f.length === 3) {
          indices.push(f[0], f[1], f[2]);
        }
      }
      geometry.setIndex(indices);
      geometry.computeVertexNormals();

      return new THREE.Mesh(
        geometry,
        new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0, roughness: 1 })
      );
    }

    function onClick(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(scene.children, true);

      if (intersects.length > 0) {
        const object = intersects[0].object;
        showMetadata(object.userData);
      }
    }

    function showMetadata(data) {
      const box = document.getElementById('infoBox');
      box.textContent = JSON.stringify(data, null, 2);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
