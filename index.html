<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Rhino Mesh Viewer â€” Metadata</title>
  <style>
    body { margin: 0; overflow: hidden; background: #f5f5f5; }
    canvas { display: block; }
    #infoBox {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: rgba(255,255,255,0.95);
      color: black;
      padding: 10px;
      border-radius: 6px;
      max-width: 350px;
      font-family: monospace;
      font-size: 12px;
      white-space: pre-wrap;
    }
    #filterBox {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.95);
      padding: 8px;
      border-radius: 6px;
      font-family: sans-serif;
      font-size: 13px;
    }
    #filterBox select {
      margin: 3px 0;
      width: 180px;
    }
  </style>
</head>
<body>
<div id="filterBox">
  <label>Key:</label><br>
  <select id="keySelect"></select><br>
  <label>Value:</label><br>
  <select id="valueSelect"></select>
</div>
<div id="infoBox">Click on a mesh to see metadata...</div>

<!-- Three.js r146 + non-module OrbitControls -->
<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://unpkg.com/rhino3dm/rhino3dm.js"></script>

<script>
let scene, camera, renderer, controls, raycaster, mouse, rhino;
let lastSelected = null;
const meshEdges = [];
const meshes = []; // keep track of all meshes
const allKeys = new Set();

async function init() {
  rhino = await rhino3dm();

  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(20,20,20);

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0xf5f5f5, 1);
  document.body.appendChild(renderer.domElement);

  controls = new THREE.OrbitControls(camera, renderer.domElement);

  scene.add(new THREE.AmbientLight(0xffffff, 1.2));
  const hemi = new THREE.HemisphereLight(0xffffff,0x444444,0.6);
  hemi.position.set(0,200,0);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff,0.8);
  dir.position.set(50,50,50);
  scene.add(dir);

  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();
  window.addEventListener('click', onClick, false);
  window.addEventListener('resize', onWindowResize, false);

  const url = 'model.3dm';
  const request = await fetch(url);
  const buffer = await request.arrayBuffer();
  const doc = rhino.File3dm.fromByteArray(new Uint8Array(buffer));

  for (let i=0; i<doc.objects().count; i++){
    const obj = doc.objects().get(i);
    const geom = obj.geometry();
    const attrs = obj.attributes();

    if (geom instanceof rhino.Mesh) {
      const mesh = meshToThree(geom);
      mesh.userData = extractMetadata(attrs, doc);
      meshes.push(mesh);

      // collect all user string keys
      for (const k in mesh.userData.userStrings) allKeys.add(k);

      scene.add(mesh);
    }
  }

  scene.rotation.x = -Math.PI/2;

  const box = new THREE.Box3().setFromObject(scene);
  const center = box.getCenter(new THREE.Vector3());
  const size = box.getSize(new THREE.Vector3()).length();
  camera.position.set(center.x+size, center.y+size, center.z+size);
  camera.lookAt(center);
  controls.target.copy(center);
  controls.update();

  setupUI(); // fill dropdowns
  animate();
}

function meshToThree(rhinoMesh){
  const geometry = new THREE.BufferGeometry();
  const verts = [];
  const vertices = rhinoMesh.vertices();
  for(let i=0; i<vertices.count; i++){
    const pt = vertices.get(i);
    verts.push(pt[0], pt[1], pt[2]);
  }
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(verts,3));

  const indices = [];
  const faces = rhinoMesh.faces();
  for(let i=0; i<faces.count; i++){
    const f = faces.get(i);
    if(f.length===4){ indices.push(f[0],f[1],f[2]); indices.push(f[0],f[2],f[3]); }
    else if(f.length===3){ indices.push(f[0],f[1],f[2]); }
  }
  geometry.setIndex(indices);
  geometry.computeVertexNormals();

  const material = new THREE.MeshStandardMaterial({color:0xcccccc, metalness:0, roughness:1});
  const mesh = new THREE.Mesh(geometry, material);

  const edges = new THREE.EdgesGeometry(geometry);
  const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color:0x000000}));
  line.position.copy(mesh.position);
  line.rotation.copy(mesh.rotation);
  scene.add(line);
  meshEdges.push({mesh, line});

  return mesh;
}

function extractMetadata(attrs, doc){
  let meta = {
    name: attrs.name || "",
    layer: doc.layers().get(attrs.layerIndex || 0).name,
    userStrings: {}
  };
  const us = attrs.getUserStrings ? attrs.getUserStrings() : null;
  if(us) for(const [k,v] of us) meta.userStrings[k] = v;
  return meta;
}

function onClick(event){
  mouse.x = (event.clientX/window.innerWidth)*2-1;
  mouse.y = -(event.clientY/window.innerHeight)*2+1;
  raycaster.setFromCamera(mouse,camera);
  const intersects = raycaster.intersectObjects(meshes,true);

  if(intersects.length>0){
    const obj = intersects[0].object;
    if(lastSelected) lastSelected.material.color.set(0xcccccc);
    obj.material.color.set(0xff0000);
    lastSelected = obj;
    showMetadata(obj.userData);
  }
}

function showMetadata(data){
  document.getElementById('infoBox').textContent = JSON.stringify(data,null,2);
}

function onWindowResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate(){
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}

// -------- UI for filtering ----------
function setupUI(){
  const keySelect = document.getElementById('keySelect');
  const valueSelect = document.getElementById('valueSelect');

  // populate keys
  allKeys.forEach(k => {
    let opt = document.createElement('option');
    opt.value = k; opt.textContent = k;
    keySelect.appendChild(opt);
  });

  // update values when key changes
  keySelect.addEventListener('change', () => {
    const key = keySelect.value;
    const values = new Set();
    meshes.forEach(m => {
      if(m.userData.userStrings[key]) values.add(m.userData.userStrings[key]);
    });
    valueSelect.innerHTML = "";
    values.forEach(v => {
      let opt = document.createElement('option');
      opt.value = v; opt.textContent = v;
      valueSelect.appendChild(opt);
    });
  });

  // highlight meshes when value picked
  valueSelect.addEventListener('change', () => {
    const key = keySelect.value;
    const val = valueSelect.value;
    meshes.forEach(m => {
      if(m.userData.userStrings[key] === val){
        m.material.color.set(0xff0000);
      } else {
        m.material.color.set(0xcccccc);
      }
    });
  });

  // trigger initial fill
  if(allKeys.size>0){
    keySelect.value = [...allKeys][0];
    keySelect.dispatchEvent(new Event('change'));
  }
}

// Initialize
init();
</script>
</body>
</html>
