<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rhino Mesh Viewer â€” Metadata + Filters + Clear</title>
  <style>
    body { margin: 0; overflow: hidden; background: #f5f5f5; }
    canvas { display: block; }

    #filterBox {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.95);
      padding: 8px;
      border-radius: 6px;
      font-family: sans-serif;
      font-size: 13px;
      z-index: 5;
    }
    #filterBox select { margin: 3px 0; width: 200px; }

    #qtyBox { margin-top: 6px; font-weight: bold; display: none; }

    #clearBtn {
      margin-top: 8px;
      padding: 4px 8px;
      font-size: 12px;
      border: 1px solid #aaa;
      border-radius: 4px;
      background: #eee;
      cursor: pointer;
    }
    #clearBtn:hover { background: #ddd; }

    #infoBox {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: rgba(255,255,255,0.95);
      color: black;
      padding: 10px;
      border-radius: 6px;
      max-width: 420px;
      max-height: 200px; /* limit height */
      overflow-y: auto;  /* scroll when too big */
      font-family: monospace;
      font-size: 12px;
      white-space: pre-wrap;
      z-index: 5;
    }
  </style>
</head>
<body>
  <div id="filterBox">
    <label>Key:</label><br>
    <select id="keySelect"></select><br>
    <label>Value:</label><br>
    <select id="valueSelect"></select><br>
    <div id="qtyBox">Qty: 0</div>
    <button id="clearBtn">Clear Selection</button>
  </div>

  <div id="infoBox">Click on a mesh to see metadata...</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/rhino3dm/rhino3dm.js"></script>

  <script>
    const DEFAULT_COLOR = 0xcccccc;
    const FILTER_COLOR  = 0xffa500;
    const SELECT_COLOR  = 0xff0000;

    let scene, camera, renderer, controls, raycaster, mouse, rhino;
    const meshes = [];
    const meshEdges = [];
    const allKeys = new Set();
    let selectedObjects = [];
    let currentFilterKey = null;
    let currentFilterVal = null;

    async function init() {
      rhino = await rhino3dm();
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.set(20,20,20);
      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0xf5f5f5, 1);
      document.body.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);

      scene.add(new THREE.AmbientLight(0xffffff, 1.2));
      const hemi = new THREE.HemisphereLight(0xffffff,0x444444,0.6);
      hemi.position.set(0,200,0);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff,0.8);
      dir.position.set(50,50,50);
      scene.add(dir);

      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
      window.addEventListener('click', onClick, false);
      window.addEventListener('resize', onWindowResize, false);

      document.getElementById('clearBtn').addEventListener('click', clearSelection);

      // Load model
      const url = 'model.3dm';
      const request = await fetch(url);
      const buffer = await request.arrayBuffer();
      const doc = rhino.File3dm.fromByteArray(new Uint8Array(buffer));

      for (let i=0; i<doc.objects().count; i++){
        const obj = doc.objects().get(i);
        const geom = obj.geometry();
        const attrs = obj.attributes();

        if (geom instanceof rhino.Mesh) {
          const mesh = meshToThree(geom);
          mesh.userData = extractMetadata(attrs, doc);
          meshes.push(mesh);
          const us = mesh.userData.userStrings || {};
          for (const k in us) allKeys.add(k);
          scene.add(mesh);
        }
      }

      scene.rotation.x = -Math.PI/2;
      const box = new THREE.Box3().setFromObject(scene);
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3()).length();
      camera.position.set(center.x+size, center.y+size, center.z+size);
      camera.lookAt(center);
      controls.target.copy(center);
      controls.update();

      setupUI();
      updateMeshColors();
      animate();
    }

    function meshToThree(rhinoMesh){
      const geometry = new THREE.BufferGeometry();
      const verts = [];
      const vertices = rhinoMesh.vertices();
      for(let i=0; i<vertices.count; i++){
        const pt = vertices.get(i);
        verts.push(pt[0], pt[1], pt[2]);
      }
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(verts,3));

      const indices = [];
      const faces = rhinoMesh.faces();
      for(let i=0; i<faces.count; i++){
        const f = faces.get(i);
        if(f.length===4){ indices.push(f[0],f[1],f[2]); indices.push(f[0],f[2],f[3]); }
        else if(f.length===3){ indices.push(f[0],f[1],f[2]); }
      }
      geometry.setIndex(indices);
      geometry.computeVertexNormals();

      const material = new THREE.MeshStandardMaterial({color: DEFAULT_COLOR, metalness:0, roughness:1});
      const mesh = new THREE.Mesh(geometry, material);

      const edges = new THREE.EdgesGeometry(geometry);
      const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color:0x000000}));
      line.position.copy(mesh.position);
      line.rotation.copy(mesh.rotation);
      scene.add(line);
      meshEdges.push({mesh, line});
      return mesh;
    }

    function extractMetadata(attrs, doc){
      let meta = {
        name: attrs.name || "",
        layer: doc.layers().get(attrs.layerIndex || 0).name,
        userStrings: {}
      };
      const us = attrs.getUserStrings ? attrs.getUserStrings() : null;
      if (us) for (const [k,v] of us) meta.userStrings[k] = v;
      return meta;
    }

    function updateMeshColors(){
      meshes.forEach(m => {
        const isSelected = selectedObjects.includes(m);
        const matchesFilter = currentFilterKey && currentFilterVal &&
          (m.userData.userStrings && m.userData.userStrings[currentFilterKey] === currentFilterVal);
        if (isSelected) m.material.color.setHex(SELECT_COLOR);
        else if (matchesFilter) m.material.color.setHex(FILTER_COLOR);
        else m.material.color.setHex(DEFAULT_COLOR);
      });
    }

    function onClick(event){
      mouse.x = (event.clientX/window.innerWidth)*2 - 1;
      mouse.y = -(event.clientY/window.innerHeight)*2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(meshes, true);
      if (!intersects.length) return;

      const obj = intersects[0].object;
      if (!obj.isMesh) return;

      const idx = selectedObjects.indexOf(obj);
      if (idx === -1) selectedObjects.push(obj);
      else selectedObjects.splice(idx, 1);

      updateMeshColors();
      showMetadata();
    }

    function showMetadata(){
      const box = document.getElementById('infoBox');
      if (!selectedObjects.length) {
        box.textContent = "Click on a mesh to see metadata...";
        return;
      }
      const info = { qty: selectedObjects.length, items: selectedObjects.map(o => o.userData) };
      box.textContent = "Qty Selected: " + info.qty + "\n\n" + JSON.stringify(info.items, null, 2);
    }

    function clearSelection(){
      selectedObjects = [];
      updateMeshColors();
      showMetadata();
    }

    function onWindowResize(){
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate(){
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    function setupUI(){
      const keySelect = document.getElementById('keySelect');
      const valueSelect = document.getElementById('valueSelect');
      const qtyBox = document.getElementById('qtyBox');

      keySelect.innerHTML = "";
      if (!allKeys.size)
