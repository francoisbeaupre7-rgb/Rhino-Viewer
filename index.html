<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>GLB Viewer (Three.js)</title>
  <style>body{margin:0;overflow:hidden}canvas{display:block}</style>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/controls/OrbitControls.js"></script>

  <script>
  // --- utilities
  function getQueryParam(name){
    const params = new URLSearchParams(window.location.search);
    return params.has(name) ? params.get(name) : null;
  }
  function safeParseJSON(s){
    try { return JSON.parse(s); } catch(e){ return null; }
  }

  // --- basic scene
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf0f0f0);
  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
  camera.position.set(3,3,6);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  const dir = new THREE.DirectionalLight(0xffffff,1); dir.position.set(5,10,7); scene.add(dir);
  scene.add(new THREE.AmbientLight(0x888888));

  // --- load model directly from local GitHub Pages repo
const loader = new THREE.GLTFLoader();
let gltfScene = null;

loader.load("model.glb", g => {
  gltfScene = g.scene;
  scene.add(gltfScene);
  fitView();
  render();
}, undefined, e => {
  console.error('GLB load error:', e);
  alert('Error loading model. Check that model.glb is in the same folder as viewer.html');
});

  }

  function fitView(){
    if(!gltfScene) return;
    const box = new THREE.Box3().setFromObject(gltfScene);
    const size = box.getSize(new THREE.Vector3());
    const center = box.getCenter(new THREE.Vector3());
    const maxDim = Math.max(size.x,size.y,size.z);
    const fov = camera.fov * (Math.PI/180);
    const dist = Math.abs(maxDim / (2*Math.tan(fov/2)));
    camera.position.set(center.x+dist, center.y+dist, center.z+dist);
    camera.lookAt(center);
    controls.target.copy(center);
    controls.update();
  }

  // --- recolor function by object name
  function recolorObjects(meta){
    if(!meta || !gltfScene) return;
    gltfScene.traverse(child=>{
      if(child.isMesh && child.name){
        const col = meta[child.name] || meta[child.name.replace(/\s+/g,'_')];
        if(col){
          // reuse material if same color for efficiency
          child.material = new THREE.MeshStandardMaterial({color: col, metalness: 0.1, roughness: 0.8});
          child.material.needsUpdate = true;
        }
      }
    });
    render();
  }

  // --- read metadata from ?meta=<urlencoded JSON> or ?metaUrl=<json file url>
  const metaParam = getQueryParam('meta');
  if(metaParam){
    const parsed = safeParseJSON(decodeURIComponent(metaParam));
    if(parsed) recolorObjects(parsed);
  } else if(getQueryParam('metaUrl')){
    fetch(decodeURIComponent(getQueryParam('metaUrl'))).then(r=>r.json()).then(j=>recolorObjects(j)).catch(e=>console.warn('metaUrl fetch failed',e));
  }

  // --- postMessage support (useful if parent page sends dynamic colors)
  window.addEventListener('message', ev=>{
    try {
      const d = typeof ev.data === 'string' ? JSON.parse(ev.data) : ev.data;
      if(d && d.type === 'recolor' && d.meta) recolorObjects(d.meta);
    } catch(e){ /* ignore */ }
  });

  // --- basic render
  function render(){ renderer.render(scene, camera); }
  function animate(){ requestAnimationFrame(animate); controls.update(); render(); }
  animate();

  // --- resize
  window.addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); render(); });

  </script>
</body>
</html>


