<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Rhino Viewer — Metadata Click</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #f5f5f5; /* light background */
    }
    canvas {
      display: block;
    }
    #infoBox {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.95);
      color: black;
      padding: 10px;
      border-radius: 6px;
      max-width: 350px;
      font-family: monospace;
      font-size: 12px;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <div id="infoBox">Click on a surface to see metadata...</div>

  <!-- Three.js + Rhino3dm -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="https://unpkg.com/rhino3dm/rhino3dm.js"></script>
  <script src="https://unpkg.com/three/examples/jsm/loaders/3DMLoader.js"></script>

  <script>
    let scene, camera, renderer, raycaster, mouse, rhino;

    init();
    animate();

    async function init() {
      rhino = await rhino3dm();

      scene = new THREE.Scene();

      // Camera
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(20, 20, 20);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0xf5f5f5, 1); // light background
      document.body.appendChild(renderer.domElement);

      // Lights
      scene.add(new THREE.AmbientLight(0xffffff, 1.2));
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
      hemiLight.position.set(0, 200, 0);
      scene.add(hemiLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(50, 50, 50);
      scene.add(dirLight);

      // Raycaster for picking
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
      window.addEventListener('click', onClick, false);

      // Load Rhino 3DM model
      const url = 'model.3dm'; // replace with your file
      const request = await fetch(url);
      const buffer = await request.arrayBuffer();
      const doc = rhino.File3dm.fromByteArray(new Uint8Array(buffer));

      console.log("Model objects:", doc.objects().count);

      for (let i = 0; i < doc.objects().count; i++) {
        const obj = doc.objects().get(i);
        const geom = obj.geometry();
        const attrs = obj.attributes();

        // Convert Rhino geometry → Three.js
        const threeMesh = meshFromGeometry(geom);
        if (threeMesh) {
          // Extract metadata
          let meta = {
            name: attrs.name(),
            layer: doc.layers().get(attrs.layerIndex()).name,
            userStrings: {}
          };

          const us = attrs.userStrings();
          if (us) {
            for (let [key, value] of us) {
              meta.userStrings[key] = value;
            }
          }

          threeMesh.userData = meta;
          scene.add(threeMesh);
        }
      }

      window.addEventListener('resize', onWindowResize, false);
    }

    // Simple converter: meshes only (expandable for curves/surfaces if needed)
    function meshFromGeometry(geom) {
      if (geom instanceof rhino.Mesh) {
        const threeGeom = new THREE.BufferGeometry();
        const vertices = geom.vertices();
        const faces = geom.faces();

        const verts = [];
        for (let i = 0; i < vertices.count; i++) {
          const pt = vertices.get(i);
          verts.push(pt[0], pt[1], pt[2]);
        }
        threeGeom.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));

        const indices = [];
        for (let i = 0; i < faces.count; i++) {
          const f = faces.get(i);
          if (f.length === 4) {
            indices.push(f[0], f[1], f[2]);
            indices.push(f[0], f[2], f[3]);
          } else if (f.length === 3) {
            indices.push(f[0], f[1], f[2]);
          }
        }
        threeGeom.setIndex(indices);
        threeGeom.computeVertexNormals();

        return new THREE.Mesh(threeGeom, new THREE.MeshStandardMaterial({ color: 0xcccccc }));
      }
      return null;
    }

    function onClick(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(scene.children, true);

      if (intersects.length > 0) {
        const object = intersects[0].object;
        showMetadata(object.userData);
      }
    }

    function showMetadata(data) {
      const box = document.getElementById('infoBox');
      box.textContent = JSON.stringify(data, null, 2);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
